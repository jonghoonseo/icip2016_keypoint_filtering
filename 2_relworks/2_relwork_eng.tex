%!TEX root = ../icip_jseo.tex
% -*- root: ../icip_jseo.tex -*-


\section{Related Works}
\label{sec:relworks}

%Planar Model based marker-less AR을 제공하기 위해서는 그림 xx\todo{순서도 삽입}과 같은  Feature Matching 기반의 알고리즘이 수행된다. 먼저 오프라인 학습 과정에서는 reference images 에서 keypoint를 detect한다. 이렇게 detect 된 keypoint들에서 다양한 연산을 통하여 distortion에 invariance하게 keypoint를 describe할 수 있는 descriptor를 생성한다. 생성된 descriptor들을 이용하여 online 단계에서 쉽게 검색할 수 있도록 matching data structure를 학습(train) 한다. 이 후 online 단계에서는 입력된 query image에서 offline process와 동일한 algorithm으로 keypoint를 detect하고 describe한다. 이렇게 계산된 descriptor들을 미리 학습된 matching data structure에서 nearest neighbor 를 검색하여 correspondence를  구성한다. 구성된 correspondence를 일정 기준에 의하여 좋은 pair만 filter하고, 최종 남은 correspondence를 이용하여 robust pose estimation을 수행하여 camera extrinsic parameter를 계산하게 된다. 계산된 extrinsic parameter를 이용하여 3차원 object를 rendering하는 순서로 수행이 된다.

To provide 'Planar Model based Marker-less AR', the feature matching based algorithm shown in Figure \ref{fig:markerless_feature_process} is performed. First, in the offline learning process, the keypoints are detected in the reference images. In the keypoints detected as above, the descriptors that are able to describe the keypoints invariably against the distortion are generated by way of computation in various ways. To facilitate the quick reference in the online phase using the descriptors generated, the matching data structure needs to be trained. After that, in the online phase, the keypoints are detected and described in the input query images using the algorithm in the offline process. The descriptors calculated as above search the nearest neighbors in the matching data structure that was already trained and compose correspondence. Only good pairs are filtered from the correspondence composed in compliance with the specific standard and then robust pose estimation is performed to calculate camera extrinsic parameters using the final correspondence residue. After that, 3-D objects rendering is performed using the calculated extrinsic parameters. 
\begin{figure}[ht!]
\centering
\includegraphics[width=0.6\textwidth]{2_relworks/process}
\caption{Feature based MarkerlessAR Process}
\label{fig:markerless_feature_process}
\end{figure}

%하지만 이러한 feature matching 기반의 markerless AR 알고리즘은 연산량이 많기 때문에 mobile phone과 같은 smart space 환경에서는 자연스러운 동작이 어렵다. 이를 극복하기 위하여 다양한 경량화 알고리즘들이 제안되고 있다. 특히, 그림 xxx\todo{매칭 속도 비교 새 버전 입력}에서 보듯이 전체적인 연산 성능에 큰 영향을 미치는 단계인 feature description과 matching 단계에 대한 속도 향상이 많이 이루어지고 있다.

However, since this feature matching based markerless AR algorithm requires a large amount of computation, the natural motion is hard to achieve in a smart space environment such as mobile phone. To overcome this limitation, various lightweight algorithms are proposed. As shown in Figure \ref{fig:markerless_relative_timings}, the speed in the feature description and matching phase that greatly affects the overall computational performance has significantly improved. 

\begin{figure}[hb!]
\centering
\includegraphics[width=0.9\textwidth]{2_relworks/time_comparison}
\caption{Relative timings of the SIFT tracker \cite{wagner_pose_2008}}
\label{fig:markerless_relative_timings}
\end{figure}


%먼저, keypoint descriptor는 기존의 SIFT\cite{lowe_distinctive_2004}나 SURF\cite{bay_speeded-up_2008}와 같은 vector value-based description 방법은 높은 인식율을 제공해 주었지만, orientation과 scale 등의 distortion에 robust한 descriptor를 생성하기 위하여 복잡한 연산을 수행하여야 하기 때문에 연산이 복잡하게 수행되었다. 따라서 최근에는 BRIEF\cite{calonder_brief:_2010}, ORB\cite{rublee_orb:_2011}, BRISK\cite{leutenegger_brisk:_2011}, FREAK\cite{alahi_freak:_2012}과 같은 다양한 Binary value-based descriptor들이 개발되고 있다. 이러한 Binary descriptor들은 그림 xxx\todo{binary desciprot 패치 }와 같이 특징점을 중심으로 다양한 형태의 패턴을 이용하여 두 점 사이의 밝기 값을 비교하여 binary code로 표현하는 방법이다. 단순 비교 연산만으로 descriptor를 계산하기 때문에 vector-based descriptor에 비하여 연산 속도가 상당히 빠르며, 최근에는 생성 패턴을 기준으로 orientation이나 scale 등을 normalize 하기 때문에 다양한 distortion에서도 상당히 강인한 성능을 보여주고 있다. 특히 smart space와 같이 제한된 성능의 환경에서는 vector-value descriptor 기반의 복잡한 연산 보다는 단순 비교연산만으로도 처리가 가능한 binary descriptor를 사용하는 연구가 많아지고 있다. 

First, in the study of keypoint descriptor`, the established vector value-based description methods such as SIFT\cite{lowe_distinctive_2004} or SURF\cite{bay_speeded-up_2008} provided high recognition rate, but complex computation was performed to generate the robust descriptors against the distortion such as orientation and scale, etc. In recent years, a wide range of binary value-based descriptors, such as  BRIEF\cite{calonder_brief:_2010}, ORB\cite{rublee_orb:_2011}, BRISK\cite{leutenegger_brisk:_2011}, FREAK\cite{alahi_freak:_2012}, are under development. These binary descriptors compare the brightness values with focus on the keypoints as shown in Figure \ref{fig:marker_experiment_environment} by using a wide range of form patterns and express the results in binary codes. Since descriptors are computed only by a simple comparison computation, its computational speed is significantly faster than vector-based descriptors. Moreover, since the orientation and scale are normalized on the basis of generation patterns, they show significantly rigid performance against a wide range of distortion. In particular, studies using the binary descriptors that can be processed by simple comparison computation rather than complex vector-value descriptor based computation are increasing in the environment of limited performance such as a smart space.  

\begin{figure}[hb!]
  \centering     %%% not \center
    \subfigure[BRISK\cite{leutenegger_brisk:_2011} Sampling Pattern]{\label{fig:markerless_brisk}\includegraphics[width=0.48\textwidth]{2_relworks/brisk}}
    \hfill
    \subfigure[FREAK\cite{alahi_freak:_2012} Sampling Pattern]{\label{fig:markerless_freak}\includegraphics[width=0.48\textwidth]{2_relworks/freak}}
  \caption{Sampling Patterns of Binary Descriptors}
    \label{fig:markerless_binary_patterns}
\end{figure}


%다음 방법은 matching data structure를 효율적으로 설계하여 nearest neighbor match를 빠르게 수행하도록 하고 있다. 기존의 brute force matching 방법은 query image의 모든 keypoint들을  reference image의 모든 keypoint들과 비교하는 방식으로 가장 속도가 오래 걸리지만, 가장 정확한 nearest neighbor를 검출할 수 있다는 장점이 있다. 이를 개선하기 위하여 다양한 tree 기반의 approximated nearest neighbor 검출 기법들이 사용된다. \cite{beis_shape_1997}에서는 kD tree 기반의 approximation 방법이 제안되었다. 이 방법은 특징의 차원이 비교적 적은 SIFT나 SURF와 같은  vector-value description 방식에서는 좋은 성능을 보여주지만, 최근에 사용되는 binary descriptor에서는 dimension이 높아 성능향상을 기대하기 어렵다는 문제가 있다. LSH\cite{gionis_similarity_1999}와 같은 Hashing 기반의 structure를 이용하여 matching 을 가속화하는 방법도 제안되었다\cite{rublee_orb:_2011}. 이러한 방법은 offline training 단계에서 적절히 특징점들이 고르게 분포하도록 적절한 hash function set을 구성하는 것이 중요하다. 또한, Random Forest\cite{lepetit_keypoint_2006} 또는 Random Fern \cite{ozuysal_fast_2010}은 Binary Description 방식을 Tree 구조 또는 List 구조에 적용하여 matching structure를 구성하였다. 이러한 매칭 방식들은 인식의 속도를 향상시키고, 좀 더 정확한 approximation 값을 얻기 위하여 일반적으로 offline training 단계에서 계산된 descriptor들을 이용하여 추가의 연산을 적용하여 효율적인 matching structure를 생성한다. 하지만, 이러한 방법들을 사용한 추가적인 구조체가 상당히 복잡하고 용량이 크기 때문에 모바일 환경에서 사용하기에 매칭 구조체가 과도하게 무거워진다는 문제점이 존재한다. 또한, detected keypoint의 성질에 대한 고려가 없기 때문에 detected keypoint set이 분류가 어려운 set 일 경우에는 성능 저하가 크게 된다는 한계가 존재한다. 따라서 본 학위논문에서는 이러한 방법을 해결하기 위하여 Keypoint Filtering 기반의 향상된 매칭 방법을 제안한다.

Having designed an efficient matching data structure, the following methods perform nearest neighbor matching quickly. The established brute force matching compares all the keypoints of query images with all the keypoints of reference images so is the slowest, but has the advantage of being able to detect the most accurate nearest neighbors. kD tree based approximation method is proposed in \cite{beis_shape_1997}. This method shows good performance in the vector-value descriptor method such as SIFT or SURF with relatively low dimension of features but the improvement of its performance is unlikely to be achieved in the latest binary descriptor with high dimension. A method enabling it to accelerate matching using Hashing based structure in LSH\cite{gionis_similarity_1999} was proposed\cite{rublee_orb:_2011}. As for this method, it is critical to compose appropriate hash function set to distribute the keypoints points evenly in the offline training phase. In addition, 'Random Forest\cite{lepetit_keypoint_2006}' or 'Random Fern\cite{ozuysal_fast_2010}' composed a matching structure by applying a binary description method to the tree structure or list structure. To increase the recognition speed and obtain more accurate approximation values, these matching methods generate efficient matching structure by way of the application of supplementary computation using the descriptors computed in the offline training phase. However, since the supplementary structure that uses this method is complex and large, its the matching structure is too heavy to use in a mobile environment. Moreover, since the properties of the detected keypoints are not taken into consideration, the set for which it is difficult to classify the detected keypoints may lead to performance degradation. To solve this problem, this dissertation proposes a keypoints filtering based matching methods.  
